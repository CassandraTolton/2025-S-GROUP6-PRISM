from rest_framework.permissions import BasePermission
import logging
# used for logging access to views. This creates a 'logger' thats named based on this specific app (users.permissions)
logger = logging.getLogger(__name__)

# to be used by a view. Its up to us to decide what gets logged this way, and what specifically is passed as 'action' and 'resource'
def log_role_access(user, action, resource):
    logger.info(f"{user} performed {action} on {resource}")
'''
heres how we could use this in a view (generated by GPT)
from users.permissions import log_role_access

def view_report(request, report_id):
    report = get_object_or_404(Report, id=report_id)
    
    # Log the access
    log_role_access(request.user, "viewed", f"Report {report_id}")
    # could also log profs deleting assignments, or anything really...

    return Response({"message": "Report accessed"})
'''


# In users/permissions.py
def is_professor(user):
    return user.groups.filter(name='Professor').exists()

def is_ta(user):
    return user.groups.filter(name='TA').exists()

def is_admin(user):
    return user.is_staff or user.is_superuser


'''
Use this function for restricting / granting access to certain endpoints.
I could do separate classes for prof and admin. but this is easier when a view is accessable by more than
one role. Its basically used if theres certain views TAs arent allowed to access.

the func 'has_permissions' will automatically get called if we do this in a view:
class RestrictedView(viewsets.ModelViewSet):
    permission_classes = [IsAuthenticated, IsProfessorOrAdmin]'''
class IsProfessorOrAdmin(BasePermission):
    def has_permission(self, request, view):
        '''stuff like request.user is built into DRF. If the user is authenticated, the .user we reference
        here will be our own instance of a user. If it hasn't been authenticated yet, its set to "AnonymousUser"
        this is a special Django class used for unauthenticated users.
        
        The .is_authenticated is an actual boolean for if the user is authenticated or not.
        
        So it makes sure the user exists, theyre authenticated, and returns true if theyre a prof or Admin.'''
        return request.user and request.user.is_authenticated and (is_professor(request.user) or is_admin(request.user))

# for more restrictive views
class IsProfessor(BasePermission):
    def has_permission(self, request, view):
        return request.user and request.user.is_authenticated and is_professor(request.user) 

class IsAdmin(BasePermission):
    def has_permission(self, request, view):
        return request.user and request.user.is_authenticated and is_admin(request.user)

# Heres how a view could call this function (inside its class)
'''
def foo(self, request):
        if not isProfessorOrTA(request.user):
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
        return Response({"message": "Access granted to prof or TA"}, status=status.HTTP_200_OK)
'''


